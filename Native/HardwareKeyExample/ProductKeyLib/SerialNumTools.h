#pragma once
#include <string>
#include "LockControl\LockControl.h"
#include "Tools\CheckSerial.h"
#include "SerialNumTools.h"
#include "Tools\XorShift.h"
#include <QObject>
#include <QString>
#include <QDir>
#include <QCryptographicHash>
#include <QMessageBox>
#include <qaction.h>
#include "windows.h"

using std :: string;

//Имя файла контейнера ключа продукта.
#define productKeyContainerName "libapr_tsvn32.a"


class SerialNumTools: public QObject
{
	Q_OBJECT

public:
	SerialNumTools();
	~SerialNumTools();

	//Получаю блок данных из контейнера, в котором хранятся серийный номер.
	// =-n ошибка при работе метода. =1 все хорошо.
	int GetSerialDataBlock(QByteArray &Ba);

	//Получает числовой ряд,контрольная числовая последовательность, генерируемая спец алгоритмом.
	//<0-ошибка.
	int GetZeroNumberSeries(QByteArray &Ba);

	//Усложняет подделку libVr5b.dll. Сравнивает значение числового ряда который всегда должен содержаться в контейнере
	//с вычисленными значениями. В случае успеха =1, при ошибке=0;
	int CheckZeroNumberSeries(QByteArray &Ba);

		//Проверяет файл на пустоту
	//int ChekSnFileToZeros();


	/* Создает контейнер для хранения серийного номера.
	   Создается файл заполненный мусором,и расширением dll.
	   Вызывается единоразово только для создания файла!!! Перед созданием установочного
	   пакета. Создает файл libapr_tsvn32.dll
	*/
	int CreateSnContainer();

	/*
	    Получает статус ключа продукта, содержащемся в контейнере.
		=0-контейнер пуст и не содержит серийного номера.
		=1-контейнер содержит серийный номер.
		=<0 -возникла ошибка.
		На вход принимает контрольный псевдослучайный ряд, и блок содержащийся в файле.
	*/
	int GetSnStatusArr(QByteArray NumSeries, QByteArray BlockFromFile);

	/*
	  Анализирует состояние ключа продукта.
	  =0-нет ключа продукта в контейнере.
	  =1-ключ продукта валидный, и его срок действия не подходит к концу.
	  =14-ключ продукта валидный,но его срок действия истекает менее чем через неделю. Значение начинает возвращаться когда
	  до конца действия ключа остается неделя или меньше.
	  =15 срок действия ключа закончился.
	  =-1-возникла ошибка.
	*/
	int AnalysProductKey();

	//Помещаю серийный номер в контейнер.
	int PutProdukKeyToConteiner(string ProductKey);

	//Анализирует статус и отсылает сигнал lockControls.
	int lockAnalys(int Stts);

	//Возвращает сообщение о необходимости зарегистрировать программу.
	string getAlarmLicenseMessage();

	//Возвращает сообщение об ошибках в программе.
	string getAlarmErrorMessage(int errCode);

	//Возвращает сообщение о том что срок действия ключа продукта окончиться менее чем через неделю.
	string getAlarmMessageEndDays();


	public slots:
			//Потоковая обертка анализа ключа продукта. Генерирует сигнал haveSerialNumber.
			 void analysisProductKey();


  signals:
	void productKeyStatus(int); //Сигнал состояния ключа продукта. 
    void finished(); 	//Сигнал о завершении  работы потока
	void lockControls(); //Сигнал блокировки контролов.


private:
	string LastError; //Сведения об ошибке.
		
	//Проверяет контрольную сумму файла.
	bool CheckCrc(QByteArray Fd);

	//При некоторых условиях возвращает 512, нужна для запутывания злоумышленника при анализе кода.
	//x1=
	unsigned int get512(unsigned int x0, unsigned int x1);

	//При некоторых условиях возвращает 12, нужна для запутывания злоумышленника при анализе кода.
	unsigned int getDui(unsigned int x0, unsigned int x1);

	//Трасформирует ключ продукта в вид из которого невозможно выделить исходную строку 
	//если не знать алгоритм преобразования.
	//В случаее ошибки возвращает пустой массив.
	QByteArray modifyProductKey(string ProductKey);
	
	//Возвращает контрольную сумму для некоторого блока данных.
	QByteArray getCrc(QByteArray Ba);
	//Обрезает последние 16 байт в массиве.
	QByteArray trim16Ba(QByteArray Ba);

	//Помещает ключ продукта в массив Ba.
	void putProductKey(QByteArray &Ba, QByteArray ProductKey);

	//Помещает контрольную сумму в конец файла.
	void putCrc(QByteArray &Ba, QByteArray baCrc);
	//Сохраняет QByteArray в файл, затирая содержимое.
	//В случае ошибки возвращает false.
	bool writeBaToFile(QByteArray &Ba, QFile &file);

	//Выполняет некоторые математические операции приводящие к получению числа 29.
	int  getDig30();

	//Считывает ключ продукта из контейнера.
	string getPK(QByteArray prk);

	//Специальный метод инкремента переменной, усложняет понимание структуры дизасемблированного кода.
	void incrementDig(int &d);

	//Восстанавливает преобразованный ключ продукта.
	QByteArray unModifyProductKey(QByteArray In);

	//Возвращает количество дней до окончания действия ключа.
	//Если срок действия закончился возвращает число с минусом.
	qint64 daysEnd(string pkDateEnd);

	//На основании значения количества оставшихся дней, возращает флаги о состоянии ключа.
	//=15 срок действия ключа закончился.
	int dayAnalys(qint64 d);

	//Просто проверяет x=0 возвращает false,x=1 возвращает true.
	//Необходим для запутывания злоумышленника анализирующего дизасемблированный код.
	bool cheсkInt(int x, qint64 d);

};

/*
  Структура контейнера хранения серийного номера.

  Файл заполненный псевдослучайными числами(если на файл смотрит простой обыватель).
  Используется XorShift алгоритм.
  [ байт 0.
             псевдослучайная последовательность размеров 525 байт.
        байт 524
     [байт 525] -Блок размером 128 байт.
         [0-14 байт] -не изменные псевдо случайные числа. Служат для проверки корректности файла.
		 [15-44]-29 символов кодированного серийного номера, если пользователь ввел в программе серийный номер. Иначе
		 псевдо случайные числа позволяющие определить наличие серийного номера.
		 [45-77]-32 байта,не изменные псевдо случайные числа. Служат для проверки корректности файла.
	 [байт 525+128=653]

  байт n]
*/